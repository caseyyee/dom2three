extends layouts/master

block content

block scripts
	script(type="text/javascript", src="js/dom2three.js")
	script(type="text/javascript", src="js/lib/three.min.js")
	script(type="text/javascript", src="js/lib/OrbitControls.js")

	script.
		// bend function
		function bend( group, amount, multiMaterialObject ) {
			function bendVertices( mesh, amount, parent ) {
				var vertices = mesh.geometry.vertices;

				if (!parent) {
					parent = mesh;
				}

				for (var i = 0; i < vertices.length; i++) {
					var vertex = vertices[i];

					// apply bend calculations on vertexes from world coordinates
					parent.updateMatrixWorld();

					var worldVertex = parent.localToWorld(vertex);

					var worldX = Math.sin( worldVertex.x / amount) * amount;
					var worldZ = - Math.cos( worldVertex.x / amount ) * amount;
					var worldY = worldVertex.y 	;

					// convert world coordinates back into local object coordinates.
					var localVertex = parent.worldToLocal(new THREE.Vector3(worldX, worldY, worldZ));
					vertex.x = localVertex.x;
					vertex.z = localVertex.z+amount;
					vertex.y = localVertex.y;
				};

				mesh.geometry.computeBoundingSphere();
				mesh.geometry.verticesNeedUpdate = true;
			}

			for ( var i = 0; i < group.children.length; i ++ ) {
				var element = group.children[ i ];

				if (element.geometry.vertices) {
					if (multiMaterialObject) {
						bendVertices( element, amount, group);
					} else {
						bendVertices( element, amount);
					}
				}
			}

			if (group.children.length == 0) {
				bendVertices(group, amount);
			}

		};


		var renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		
		var scene = new THREE.Scene();
		
		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.z = 0.0001;

		var controls = new THREE.OrbitControls(camera);

		var d23 = DOM2three.load('dom2three',{
			/*
			makeMeshes option generates three.js compatible meshes.
			*/
			makeMeshes: true,
			/* 
			pixelScale sets the pixel to three.js units ratio.   1px = 1 three.js unit.
			*/
			pixelScale: 1
		});

		d23.loaded.then(function() {
			var group = new THREE.Object3D();
			var rad = 1500;
			var mesh;
			var mesh_rad_ar = [];
			var mesh_ar = [];

			group.position.set(0,0,-rad);

			d23.nodes.forEach(function(node) {
				mesh = node.mesh;

				var attributes = ['position', 'rotation'];
				var prefix = 'data-';
				var cords = ['x','y','z'];
				var mesh_property;
				var mesh_rad;

				attributes.forEach(function(attr) {
					if (node[prefix + attr]) {
						
						cords.forEach(function(cord,i) {
							// apply relative posiitoning from node properties

							
							mesh[attr][cord] += node[prefix + attr][i];
							

							// check z depth of each mesh and store into array.
							if (cord == 'z' && attr == 'position') { // only z position cords
								mesh_rad = mesh[attr][cord];
								
								if (mesh_rad_ar.indexOf(mesh_rad) == -1) {
									mesh_rad_ar.push(mesh_rad);
									mesh_ar.push(mesh);
								}
							}
							
							
						});
					}
				});

				if (mesh_ar.indexOf(mesh) == -1) {
					group.add(mesh);
				}
			});

			// 0 depth
			bend(group, rad);
			scene.add(group);

			// all other depths
			mesh_rad_ar.forEach(function(radius,i) {
				var rad_group = new THREE.Object3D();

				rad_group.position.set(0,0,-(rad+radius));
				rad_group.add(mesh_ar[i]);
				scene.add(rad_group);
				bend(rad_group, rad+radius);
			});

			animate();
		});
		
		function animate() {
			controls.update();
			renderer.render(scene, camera);
			requestAnimationFrame(animate);
		};

		

